---
title: "Brickman Walkthrough"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Table of Contents**

* [Overview](#overview)
* [Data preparation](#data-preparation)
* [Modeling](#modeling)
* [Model Evaluation](#model-evaluation)
* [Predictions and Plots](#predictions-and-plots)

This repository contains resources and a walkthrough for modeling presence/absence data in North Atlantic using covariates from [Brickman et. al. 2021](https://online.ucpress.edu/elementa/article/9/1/00055/116900/Projections-of-physical-conditions-in-the-Gulf-of). Files included in this repository are: 

* **README.md** (this document): Overview and walkthrough of Brickman modeling process 
* [**brickman_walkthrough.R**](https://github.com/oj713/brickman-walkthrough/blob/main/brickman_walkthrough.R): the complete R code used in the modeling walkthrough
* [**brickman_walkthrough_help.R**](https://github.com/oj713/brickman-walkthrough/blob/main/brickman_walkthrough_help.R): code for three helper functions that can generate predictions and plots

## Overview ##

The Brickman dataset consists of environmental covariates for a variety of climate scenarios in the North Atlantic. Covariates were generated by downscaling low-resolution IPCC data to a much higher 1/12 degree resolution. The Brickman dataset contains high resolution datasets for present day (2015), 2055, and 2075 for RCP 45 and 85 conservation scenarios. Environmental covariates available include bathymetry, bottom stress, mixed layer depth, sea surface / sea bottom temperature and salinity, and current vectors.  

**Brickman coordinate bounding box:**

 xmin = -101.5, xmax = -24.5, ymin = 16.0, ymax = 75.2 

This walkthrough provides a guide for building a presence/absence model using the Brickman dataset. By training a model with present-day covariates, we can generate high resolution projections for the four available future climate situations. Example projections are in the [Predictions and Plots](#predictions-and-plots) section. This code is beginner-friendly and can perform the entire modeling process for a provided dataset, but to improve and modify the model or predictions more coding experience may be required. 

* This code is for building a model that takes month as a covariate. Predicted output is on a monthly basis. Building an annual model is possible, but requires some changes to Brickman variable extraction. 
* All code must be run within Bigelow's ecocast server to function. To run outside of ecocast, the Brickman datasets must be downloaded and have their paths specified within `brickman` package methods. 
* This walkthrough makes use of the base R pipe operator, [`|>`](https://www.infoworld.com/article/3621369/use-the-new-r-pipe-built-into-r-41.html). 
* Questions? Comments? Contact me by email at ojohnson@bigelow.org

**Required Packages**
```{r packages, message = FALSE}
# for modeling and loading packages such as dplyr, purrr, and ggplot2
library(tidymodels) 
# for handling Brickman data 
library(stars) 
library(brickman) 
# for plotting 
library(viridis)
```

\* *The `brickman` package was written by Ben Tupper and is available on ecocast and [GitHub](https://github.com/BigelowLab/brickman).*

## Data Preparation ##

```{r seed}
set.seed(607)
```

To begin, choose your desired presence/absense data and assign it to `pa_data`. The data should be an `sf` object (crs 4326) and have the following columns: 

* `PRESENCE`: factor, either 0 or 1
* `MONTH`: numeric, 1 through 12

Make sure that all datapoints in `pa_data` are within the Brickman coordinate bounding box (see [Overview](#overview)). To convert a dataframe to `sf`, use [`st_as_sf()`](https://www.rdocumentation.org/packages/sf/versions/1.0-7/topics/st_as_sf). 

For the walkthrough, we will be using *C. Finmarchicus* data collected from the [Ecomon survey](https://www.st.nmfs.noaa.gov/copepod/data/us-05101/index.html). We will consider *C. Finmarchicus* present if there are more than 10,000 individuals per square meter. 

```{r initial data}
library(ecomon) # not needed if not working with ecomon data

# substitute your own dataset in here
pa_data <- ecomon::read_staged(species = "calfin", form = "sf") |>
  transmute(PRESENCE = (total_m2 > 10000) |> as.numeric() |> as.factor(),
            MONTH = lubridate::month(date))

pa_data
```

Next, define `VARS`, the list of Brickman environmental covariates to include in the modelling process. A complete list of available covariates is below: subset this as you desire.

* `Bathy_depth`: bathymetry
* `Xbtm`: bottom stress
* `MLD`: mixed layer depth
* `Sbtm`, `Tbtm`: sea bottom salinity, temperature
* `SSS`, `SST`: sea surface salinity, temperature
* `U`, `V`: horizontal and vertical current velocity

```{r covariates}
# COVARIATES
VARS <- c("Bathy_depth", "Xbtm", "MLD", "Sbtm", "SSS", "SST", "Tbtm", "U", "V")
```

Finally, use the `brickman::extract_points()` method to match `pa_data` to present-day Brickman covariates and create the input dataset for the model. 

* `pa_data` is matched to Brickman covariates by pairing each presence/absence location with the geographically closest Brickman datapoint.

```{r creating dataset}
# pairing brickman present data to presence data
model_data <- brickman::extract_points(brickman::compose_filename("PRESENT"), 
                                       vars = VARS, 
                                       pts = pa_data, 
                                       complete = TRUE,
                                       simplify_names = TRUE) |>
  # binding the original dataset and selecting needed columns
  bind_cols(pa_data) |>
  select(lat, lon, PRESENCE, MONTH, all_of(VARS)) |>
  rowwise() |>
  # monthly variables are returned as a list with 12 values - must extract correct month
  mutate_at(VARS[!VARS == "Bathy_depth"], ~.x[[MONTH]]) |>
  ungroup() |>
  # converting month to a factor
  # remove this line to treat month as continuous ~ requires changes to get_predictions()
  mutate(MONTH = as.factor(MONTH)) 

# input dataset for workflow
model_data
```

## Modeling ##

Next, use `Tidymodels` to build a `workflow` object modeling `model_data`. An example workflow is below, but feel free to change recipes, models, or splitting techniques as desired. 

* The example recipe converts `U` and `V` to a single `Vel` attribute representing overall current velocity. 
* For more information on modeling with `Tidymodels`, check out my [`Tidymodels Tutorial`](https://oj713.github.io/tidymodels/). 

```{r building the model}
# performing the initial testing/training split
# training data will be used to train the model, and the testing data is used
#   to assess model performance
data_split <- initial_split(model_data, prop = 3/4, strata = PRESENCE)
training_data <- training(data_split)
testing_data <- testing(data_split)

# example recipe: formula and preprocessing steps for the dataset. 
recipe <- recipe(PRESENCE ~ ., data = training_data) |>
  update_role(lat, lon, U, V, new_role = "ID") |>
  step_mutate(Vel = sqrt(U^2 + V^2), role = "predictor") |>
  step_corr(all_numeric_predictors(), threshold = .95) |>
  step_zv(all_predictors()) |>
  step_normalize(all_numeric_predictors())

# example model specification: random forest
model <- rand_forest(trees = 15) |>
  set_engine("ranger") |>
  set_mode("classification")

# workflow: bundling preprocessing and model together
workflow <- workflow() |>
  add_recipe(recipe) |>
  add_model(model) |>
  fit(training_data)

workflow
```

## Model Evaluation ##
 
Evaluate the model with whatever tools you desire. Some examples of analyses are below. 

```{r augment}
# using augment to make predictions for the test dataset 
test_results <- augment(workflow, testing_data)

# note .pred_class, .pred_0 and .pred_1 columns
dplyr::glimpse(test_results)
```

* [`Yardstick`](https://yardstick.tidymodels.org/) provides methods to easily collect performance metrics.

```{r metrics}
# defining and retrieving desired metrics
pa_metrics <- yardstick::metric_set(roc_auc, sens, spec, accuracy)
pa_metrics(test_results, 
           truth = PRESENCE, 
           estimate = .pred_class, 
           .pred_1,
           event_level = "second")
```

* By splitting the results table by month, we can collect a monthly performance breakdown.

```{r auc monthly}
# building a table that contains AUC for each month of predictions
auc_monthly <- count(test_results, MONTH) |>
  bind_cols(AUC = split(test_results, test_results$MONTH) |> 
              lapply(function(x) roc_auc_vec(x$PRESENCE,
                                             x$.pred_1,
                                             event_level = "second")) |>
      unlist()) |>
  mutate(MONTH = as.numeric(MONTH))

# plotting the AUC by month 
ggplot(data = auc_monthly, 
       mapping = aes(x = MONTH, y = AUC)) +
  geom_line() +
  geom_point() +
  scale_x_continuous(name = "Month", 
                     breaks = 1:12, 
                     labels = c("Jan", "Feb", "Mar", "Apr", 
                                "May", "Jun", "Jul", "Aug",
                                "Sep", "Oct", "Nov", "Dec")) +
  scale_y_continuous(name = "AUC", limits = c(.5, 1)) +
  ggtitle("AUC by Month") +
  theme_classic() + 
  theme(panel.grid.major.y = element_line())
```

## Predictions and Plots ##

Now, using `workflow` we can generate and visualize monthly predictions for a desired Brickman climate sitation.  [`brickman_walkthrough_help.R`](https://github.com/oj713/brickman-walkthrough/blob/main/brickman_walkthrough_help.R) defines three helper functions to assist with this portion of the modeling process: 

* **`get_predictions()`** takes a workflow and returns a list of by-month predictions for a desired climate situation. 
* **`get_value_plots()`** creates plots presence probabilities from a prediction list. 
* **`get_threshold_plots()`** creates plots showing how presence shifts between climate situations relative to a desired threshold. 

First, generate predictions using `get_predictions()`. 

* Although we trained the model on present-day data, note that I'm still generating present predictions. The training data likely will not cover the entire extent of the Brickman dataset. By generating present predictions, we can see projections for areas outside of the training data's bounds as well as create a point of reference for how predictions change between present and future climate situations.  
* The `downsample` argument represents the desired resolution of predictions. 0 represents original resolution (1 datapoint per 1/12 square degrees), and higher values represent lower resolutions. A `downsample` value is 0 is best for high-resolution predictions, but has long runtimes and resulting file sizes of 200+ MB. A `downsample` value of 2 or 3 is a better starting point. For more information on how `downsample` scales the Brickman data, see [`stars::st_downsample()`](https://r-spatial.github.io/stars/reference/st_downsample.html). This walkthrough does not contain an example of original resolution projections for memory reasons. 

```{r predictions}
source("brickman_walkthrough_help.R")

# predictions for the most extreme climate situation: RCP85 2075. 
rcp85_2075 <- get_predictions(wkf = workflow, # a fitted workflow used to predict
                              brickman_vars = VARS, # needed brickman covariates
                              year = 2075, # year of predictions
                              scenario = "RCP85", # scenario of predictions
                              augment_preds = FALSE, # bind predictions to covariates?
                              verbose = FALSE, 
                              downsample = 3) # resolution of predictions

# present day predictions
# Since I intend to compare RCP85 2075 to present day, the downsample value must be the same
present_preds <- get_predictions(wkf = workflow, 
                                 brickman_vars = VARS, 
                                 year = NA, # note that PRESENT is a scenario, not a year
                                 scenario = "PRESENT",
                                 augment_preds = FALSE,
                                 verbose = FALSE,
                                 downsample = 3)

# predictions for the least extreme future climate situation: RCP45 2055
# Generating these predictions at a higher resolution
rcp45_2055 <- get_predictions(wkf = workflow, 
                              brickman_vars = VARS,
                              year = 2055, 
                              scenario = "RCP45", 
                              augment_preds = FALSE, 
                              verbose = FALSE, 
                              downsample = 1) # higher resolution

# list of 12 tibbles of prediction data - 1 per month
length(rcp85_2075)

# can index by month number or by 3 letter abbreviation of desired month
rcp45_2055[["Oct"]]
```

There are three pre-defined ways to visualize prediction data:

* **Raw**: Plot the predicted presence probability for a climate situation. This is best for understanding where a model places presences and absences. 
* **Difference**: Plot the difference in presence probability between two different climate situations. This is best for understanding how raw probabilities may shift over time. 
* **Threshold**: Plot how presence probability shifts relative to a desired threshold. This is best for examining how high-presence areas shift between climate situations.  

Use `get_value_plots()` to retrieve raw or difference plots, and use `get_threshold_plots()` to retrieve threshold plots. Both of these methods return a list of 12 `ggplot` objects named by month. 

* If creating a difference or threshold plot, ensure that the downsample value is the same for both the original and comparison predictions. 

```{r plotting}
# raw plots for RCP85 2075
raw_plots_rcp85_2075 <- get_value_plots(preds_list = rcp85_2075, # prediction data 
                                        title = "RCP85 2075 Predicted Presence Probability",
                                         # size of points in graph - optimal value depends on crop and downsample
                                        pt_size = .3, 
                                        xlim = NULL, # optional bounds for plot, if zooming in on an area 
                                        ylim = NULL)

# Where are the predicted presence probabilities for RCP85 2075 in October?
raw_plots_rcp85_2075[["Oct"]]

# another example of raw plots, now for RCP45 2055 
# This plot is cropped to the Gulf of Maine / Gulf of St. Lawrence
raw_plots_rcp45_2055 <- get_value_plots(preds_list = rcp45_2055, 
                                        title = "RCP45 2055 Predicted Presence Probability",
                                        pt_size = .4, # note adjusted point size
                                        xlim = c(-77.0, -42.5), # cropping
                                        ylim = c(36.5,  56.7))

# What are the predicted presence probabilities for RCP45 2055 in May in the GoM/GSL? 
raw_plots_rcp45_2055[["May"]]

# difference plots for RCP85 2075 relative to present day
difference_plots <- get_value_plots(preds_list = rcp85_2075,
                                    title = "RCP85 2075 Change in Presence Probability",
                                    pt_size = .3,
                                    xlim = NULL, 
                                    ylim = NULL,
                                    # optional comparison argument indicates need for 
                                    comparison_list = present_preds)

# How have probabilities shifted between present day and RCP85 2075?
difference_plots[["Oct"]]

# threshold plots for RCP85 2075, relative to present day
threshold_plots <- get_threshold_plots(preds_list = rcp85_2075, # target prediction data
                                       comparison_list = present_preds, # comparison prediction data
                                       threshold = .5, # threshold for presence
                                       title = "Shifts in presence between Present Day and RCP85 2075",
                                       pt_size = .3,
                                       xlim = NULL,
                                       ylim = NULL)

# Where are the new, lost, and maintained presence areas in RCP85 2075 relative to present day?
threshold_plots[["Oct"]]
```

[Jump to Top](#top)
